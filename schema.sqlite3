-- for simple relationships: Product to Category
create table Relationship (id text, type text, key text, value text, language text, createdAt text, updatedAt text);

-- for tree-like relationships: Category to Sub-Category
-- http://dev.mysql.com/tech-resources/articles/hierarchical-data.html
-- Tree.name is for named trees
create table Tree (id text, type text, parent tree, name text, lft integer, rgt integer, createdAt text, updatedAt text);

-- for non-simple sorting: more-so than Product name
create table Sorting (id text, type text, tree text, lft integer, rgt integer, createdAt text, updatedAt text);

-- and I might like to pull type to id mapping out of the Relationship table
create table Type (id text, type text, createdAt text, updatedAt text);

create table Text (id text, type text, key text, value text, language text, createdAt text);
create table Integer (id text, type text, key text, value integer, language text, createdAt text);
create table Decimal (id text, type text, key text, value real , language text, createdAt text);

create index TypeId on Type (id,type);

create index DecimalCreated on Decimal (createdAt);
create index IntegerCreated on Integer (createdAt);
create index TextCreated on Text (createdAt);

--create index RelationshipKey on Relationship (id,key,language);
create index DecimalKey on Decimal (id,key,language);
create index IntegerKey on Integer (id,key,language);
create index TextKey on Text (id,key,language);

-- maybe have another scheme for auto-increment ids. would require another table and Model class
-- or maybe this is the default?
-- this is probably not the structure we want, or does it matter?
create table AutoIds (id integer auto_increment, type text, primary key (id));
