- yeah, want to remove the need to get instance dict for every modification
	- only want to get compare against the Model fields when save
	- maybe a small catch for instance dict that keeps track of which fields have been changed

- validation options with type creation ... when add a text field to a Model, specify how to validate it.
	- uniqueness?
	- callback
	- regex

- use a unit-test tool for experience

- measure speed now to get an idea, before i change the way __settattr__ works
	- saving
	- retrieval
	- probably fast enough though

- is there a python data/input validator?
	- function or regex based checking
	- return whether failed and a message
	- attach types to these validation rules so we can map them to the correct data type table

- wanted to see whether we're on auto-commit, since the initial setup of only a few objects in 00.populate.py takes a while
	- yes, autocommit is on, and takes long

- transactions around saves for an object

- give access to built-in fields: language, createdAt, updatedAt
	- maybe through fieldRevisions() method?

- model and import ecommerce database, or a subset



Done

- what about keeping revisions of an object's fields?
	- prefer to let createdAt/updatedAt do the work

- test01.py should be a simple instantiation, with a save to db, then fetch back and print

- not quite sure whether to reference module name

- tempted to add a 'bidirectional' True or False flag to the Relationship field, that way I can do away with 'reverse' and the stupid query that requires. but still, one should be 1to1, the other 1toMany. gotta be a better way.
	- or maybe, when saving a Relationship that relates a type to another type, check for the presense of the relationship in the other direction. if it exists, save in both directions.
	- so that means we need a 'oneOrMany' flag to specify how many should be returned

- instanceDict['__pending'] should only include names of fields that have changed. No sense in duplicating the values from instanceDict.

- how do we represent the top node of a tree?
	- the Category tree doesn't have a Category as the root node
	- maybe makeTree() could accept an object
	- can tree nodes be of mixed object types?
	- trees, by nature, have a node at the top, which i guess is an ok requirement

- use Hierarchy.tree to hold id of immediate parent
	- can use this to easily find siblings
